/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableSort
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  isEnabled: true,
  isDevmodeEnabled: false
};
var TableSortSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const general_heading = containerEl.createEl("div");
    general_heading.createEl("h2", { text: "General Settings" });
    new import_obsidian.Setting(containerEl).setName("Toggle table sorting").setDesc("This toggles the activation state of this plugin.").addToggle((toggle) => {
      toggle.setDisabled(false).setValue(TableSort.settings.isEnabled).onChange(async (value) => {
        TableSort.settings.isEnabled = value;
        await this.plugin.saveSettings();
        TableSort.log(`${value ? "Enabled" : "Disabled"} the 'obsidian-table-sorting' plugin.`);
      });
    });
    const developer_heading = containerEl.createEl("div");
    developer_heading.createEl("h2", { text: "Developer Settings" });
    new import_obsidian.Setting(containerEl).setName("Developer mode").setDesc("This enables development logging in the console.").addToggle((toggle) => {
      toggle.setDisabled(false).setValue(TableSort.settings.isDevmodeEnabled).onChange(async (value) => {
        TableSort.settings.isDevmodeEnabled = value;
        await this.plugin.saveSettings();
        TableSort.log(`${value ? "Enabled" : "Disabled"} the 'obsidian-table-sorting' dev mode.`);
      });
    });
  }
};

// src/icons.ts
var DRAG_HANDLE = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-home"><circle cx="12" cy="9" r="1"></circle><circle cx="19" cy="9" r="1"></circle><circle cx="5" cy="9" r="1"></circle><circle cx="12" cy="15" r="1"></circle><circle cx="19" cy="15" r="1"></circle><circle cx="5" cy="15" r="1"></circle></svg>`;
var SORT_ASC = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-down-a-z"><path d="m3 16 4 4 4-4"/><path d="M7 20V4"/><path d="M20 8h-5"/><path d="M15 10V6.5a2.5 2.5 0 0 1 5 0V10"/><path d="M15 14h5l-5 6h5"/></svg>`;
var SORT_DESC = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-down-z-a"><path d="m3 16 4 4 4-4"/><path d="M7 4v16"/><path d="M15 4h5l-5 6h5"/><path d="M15 20v-3.5a2.5 2.5 0 0 1 5 0V20"/><path d="M20 18h-5"/></svg>`;
var SORT_SELECTED = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-vote"><path d="m9 12 2 2 4-4"/><path d="M5 7c0-1.1.9-2 2-2h10a2 2 0 0 1 2 2v12H5V7Z"/><path d="M22 19H2"/></svg>`;

// src/column.ts
var Column = class {
  constructor(id, element, order, parent) {
    this.isSelected = false;
    this.order = "neutral";
    this.id = id;
    this.element = element;
    this.parent = parent;
    this.order = order;
  }
  deselect() {
    this.isSelected = false;
    this.order = "neutral";
    this.resetIcon();
    const cells = this.parent.getColumnCells(this.id);
    cells.forEach((cell) => {
      cell.classList.remove("is-selected", "top", "bottom");
    });
    this.update();
  }
  getHandle() {
    return this.element.querySelector(".table-col-drag-handle");
  }
  getIcon() {
    if (!this.isSelected) {
      return DRAG_HANDLE;
    }
    let icon;
    switch (this.order) {
      case "ascending":
        icon = SORT_ASC;
        break;
      case "descending":
        icon = SORT_DESC;
        break;
      default:
        icon = SORT_SELECTED;
    }
    return icon;
  }
  getName() {
    var _a;
    return ((_a = this.element.querySelector(".table-cell-wrapper")) == null ? void 0 : _a.innerHTML) || "No name";
  }
  getWeight() {
    if (this.order == "neutral") {
      return 0;
    }
    return this.order == "ascending" ? 1 : -1;
  }
  resetIcon() {
    let handle = this.element.querySelector(".table-col-drag-handle");
    if (!handle)
      return;
    handle.innerHTML = DRAG_HANDLE;
    handle.classList.remove("opacity-100");
  }
  select() {
    this.isSelected = true;
    const cells = [this.element].concat(this.parent.getTableRows());
    cells.forEach((row, position) => {
      TableSort.log(position);
      const isTopRow = position == 0;
      const isBottomRow = position == cells.length - 1;
      const cellType = isTopRow ? "th" : "td";
      const cell = isTopRow ? this.element : row.querySelectorAll(cellType)[this.id];
      cell.classList.remove("is-selected", "top", "bottom");
      const classes = ["is-selected", "start", "end"];
      if (isTopRow) {
        classes.push("top");
      }
      if (isBottomRow) {
        classes.push("bottom");
      }
      if (!cell.classList.contains("is-selected")) {
        cell.classList.add(...classes);
      }
    });
  }
  setIcon() {
    const handle = this.getHandle();
    if (!handle)
      return;
    handle.innerHTML = this.getIcon();
    handle.classList.add("opacity-100");
  }
  setLabel(label) {
    const handle = this.getHandle();
    if (!handle)
      return;
    handle.setAttribute("data-content", label);
    handle.innerHTML = label;
  }
  update() {
    const handle = this.getHandle();
    if (!handle)
      return;
    if (!this.isSelected) {
      this.isSelected = false;
      handle == null ? void 0 : handle.classList.remove("opacity-100");
    } else {
      this.select();
      handle == null ? void 0 : handle.classList.add("opacity-100");
    }
    const isShort = handle.offsetWidth < 100;
    if (isShort) {
      handle.classList.add("short");
    } else {
      handle.classList.remove("short");
    }
    const icon = this.getIcon();
    const priority = this.parent.getFilterPriority(this);
    const canBeShown = priority !== -1 && this.isSelected;
    const label = icon + (canBeShown ? ` (${priority})` : "");
    ;
    this.setLabel(label);
  }
};

// src/table.ts
var idPrefix = "ots-rt-";
var Table = class {
  constructor(id, element, plugin) {
    this.id = -1;
    this.filters = [];
    this.columns = [];
    this.id = id || 0;
    this.element = element;
    this.plugin = plugin;
    element.setAttribute("id", `${idPrefix}${id.toString()}`);
    this.currentOrder = this.getTableRows();
    this.originalOrder = this.currentOrder;
  }
  _resetOtherColumns(column) {
    this.columns.filter((c) => c !== column).forEach((c) => {
      c.deselect();
    });
  }
  _updateLabels() {
    this.filters.forEach((e, i) => {
      e.setLabel("(" + i.toString() + ")");
      e.setIcon();
    });
  }
  containsColumn(column) {
    const contains = this.filters.includes(column);
    TableSort.log(contains, this.filters);
    return this.filters.includes(column);
  }
  deselectAll() {
    TableSort.log("Deselecting all: ", this.columns);
  }
  handleClick(column) {
    if (column.isSelected)
      return;
    if (!this.containsColumn(column)) {
      this.reset();
    }
    this.filters.push(column);
    column.select();
  }
  fillTable() {
    this.currentOrder.forEach((row) => {
      var _a;
      (_a = this.element.querySelector("tbody")) == null ? void 0 : _a.appendChild(row);
    });
  }
  getColumnCells(position) {
    const column = this.getColumn(position);
    const cells = [column.element];
    this.getTableRows().forEach((row) => {
      const cell = row.querySelectorAll("td")[column.id];
      cells.push(cell);
    });
    return cells;
  }
  getColumn(id) {
    const element = this.getTableHeads()[id];
    if (!this.columns[id]) {
      const column = new Column(id, element, "neutral", this);
      this.columns[id] = column;
      return column;
    }
    return this.columns[id];
  }
  getColumnIndex(element) {
    var _a;
    if (!element) {
      return -1;
    }
    const tag = element.tagName;
    const cell = tag == "DIV" ? element.parentElement : element;
    const siblings = Array.prototype.slice.call((_a = cell == null ? void 0 : cell.parentElement) == null ? void 0 : _a.children);
    return siblings.indexOf(cell);
  }
  getFilterPriority(column) {
    return this.filters.indexOf(column);
  }
  getTableHeads() {
    var _a;
    this.updateElement();
    return Array.from((_a = this.element) == null ? void 0 : _a.querySelectorAll("th"));
  }
  getTableRows() {
    this.updateElement();
    const rowElements = this.element.querySelectorAll("tr");
    return Array.from(rowElements).splice(1, rowElements.length);
  }
  removeFilter(column) {
    this.filters.splice(this.filters.indexOf(column), 1);
    column.deselect();
    column.update();
  }
  removeFromFilters(column) {
    this.filters.splice(this.filters.indexOf(column), 1);
  }
  removeRows(rows) {
    Array.from(rows).forEach((row) => {
      row.remove();
    });
  }
  reset() {
    this.filters = [];
    this.columns.forEach((c) => {
      c.deselect();
    });
    this.currentOrder = this.originalOrder;
    this.sort();
  }
  selectColumn(column) {
    const cells = [column.element].concat(this.getTableRows());
    cells.forEach((row, position) => {
      const isTopRow = position == 0;
      const isBottomRow = position == cells.length - 1;
      const cellType = isTopRow ? "th" : "td";
      const cell = isTopRow ? column.element : row.querySelectorAll(cellType)[column.id];
      const classes = ["is-selected", "start", "end"];
      if (isTopRow) {
        classes.push("top");
      }
      if (isBottomRow) {
        classes.push("bottom");
      }
      if (!cell.classList.contains("is-selected")) {
        cell.classList.add(...classes);
      }
    });
    column.select();
  }
  sort() {
    const compareRows = (rowA, rowB) => {
      for (const filter of this.filters) {
        const cellA = rowA.children[filter.id];
        const cellB = rowB.children[filter.id];
        if (!cellA || !cellB) {
          return 0;
        }
        const valueA = cellA.textContent ? cellA.textContent.toLowerCase() : "";
        const valueB = cellB.textContent ? cellB.textContent.toLowerCase() : "";
        if (valueA < valueB) {
          return -1 * filter.getWeight();
        }
        if (valueA > valueB) {
          return 1 * filter.getWeight();
        }
      }
      return 0;
    };
    if (this.filters.length == 0) {
      this.currentOrder = this.originalOrder;
    } else {
      this.currentOrder = Array.from(this.currentOrder).sort((rowA, rowB) => {
        return compareRows(rowA, rowB);
      });
      TableSort.log("[obsidian-table-sorting] sort() - Finished sorting trows.");
    }
    this.fillTable();
  }
  updateColumns() {
    this.columns.forEach((column) => {
      if (!this.containsColumn(column)) {
        column.deselect();
        console.log("Deselecting column", column);
      } else {
        column.select();
      }
      column.update();
    });
  }
  updateElement() {
    const element = document.getElementById(`${idPrefix}${this.id.toString()}`);
    if (!element) {
      console.error("Found no registered table with the corresponding id.");
    }
  }
};

// src/menuHandler.ts
var ContextMenu = class {
  constructor(element, plugin) {
    if (element instanceof HTMLCollection) {
      this.element = element[0];
    } else {
      this.element = element;
    }
    this.plugin = plugin;
  }
  addAction(action, title, dataSection) {
    const menuItemHTML = `
                <div class="menu-item-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-az">
                        <path d="m3 8 4-4 4 4"></path>
                        <path d="M7 4v16"></path>
                        <path d="M20 8h-5"></path>
                        <path d="M15 10V6.5a2.5 2.5 0 0 1 5 0V10"></path>
                        <path d="M15 14h5l-5 6h5"></path>
                    </svg>
                </div>
                <div class="menu-item-title">${title}</div>
        `;
    const menuItem = document.createElement("div");
    menuItem.classList.add("menu-item");
    menuItem.setAttribute("data-section", dataSection || "");
    menuItem.innerHTML = menuItemHTML;
    menuItem.addEventListener("click", () => {
      action();
    });
    menuItem.addEventListener("mouseenter", () => {
      var _a, _b;
      (_b = (_a = menuItem.parentElement) == null ? void 0 : _a.querySelector(".selected")) == null ? void 0 : _b.classList.remove("selected");
      menuItem.classList.add("selected");
    });
    menuItem.addEventListener("mouseleave", () => {
      menuItem.classList.remove("selected");
    });
    this.element.appendChild(menuItem);
  }
  addSectionHeader(title, alignment = "left") {
    const sectionHeader = document.createElement("div");
    sectionHeader.classList.add("menu-item");
    const margin = alignment == "left" ? "margin-right: auto !important" : alignment == "right" ? "margin-left: auto !important" : `margin-left: auto !important; margin-right: auto !important`;
    const sectionHeaderHTML = `<p style="margin: 0 !important; ${margin}; color: var(--text-muted) !important;">${title}</p>`;
    sectionHeader.innerHTML = sectionHeaderHTML;
    this.element.appendChild(sectionHeader);
  }
  addSeparator() {
    const separator = document.createElement("div");
    separator.classList.add("menu-separator");
    this.element.appendChild(separator);
  }
};
async function getMenuElement() {
  const getOpenMenu = new Promise((resolve, reject) => {
    var openedMenus;
    setTimeout(() => {
      openedMenus = document.getElementsByClassName("menu");
      !openedMenus || openedMenus.length == 0 ? resolve(null) : resolve(openedMenus);
    }, 1);
  });
  getOpenMenu.then((result) => {
    if (!result) {
      TableSort.log("Did not find the contextmenu...");
      return null;
    }
    return result[0];
  });
  const menu = await getOpenMenu;
  return await getOpenMenu;
}

// src/mouseHandler.ts
var import_obsidian2 = require("obsidian");
function getMousedownHandler(plugin) {
  return async (evt) => {
    if (evt.target == null) {
      return;
    }
    const element = evt.target;
    const tableElement = plugin.getTableElement(element);
    if (!tableElement) {
      return;
    }
    if (!tableElement || !plugin.hasCustomClasses(tableElement) || !hasClickedTable(tableElement)) {
      return;
    }
    const openedMenu = await getMenuElement();
    if (!openedMenu) {
      return;
    }
    const tableID = plugin.getTableID(tableElement);
    let table;
    if (plugin.isNewTable(tableID)) {
      table = new Table(tableID, tableElement, plugin);
      plugin.storage.push(table);
      TableSort.log("New table: ", tableID);
    } else {
      table = plugin.storage[tableID];
    }
    new import_obsidian2.Notice(`Clicked table #${tableID}.`);
    const columnIndex = table.getColumnIndex(element);
    const column = table.getColumn(columnIndex);
    TableSort.log(columnIndex, column);
    const menu = new ContextMenu(openedMenu, plugin);
    menu.addSeparator();
    menu.addSectionHeader("Table Sorting - Temporary Sorting", "center");
    menu.addAction(() => {
      table.handleClick(column);
      column.order = "ascending";
      table.sort();
      table.updateColumns();
    }, "Sort temporarily by column (A to Z)", "table-sort");
    menu.addAction(() => {
      table.handleClick(column);
      column.order = "descending";
      table.sort();
      table.updateColumns();
    }, "Sort temporarily by column (Z to A)", "table-sort");
    const isSelected = column.isSelected;
    menu.addAction(
      () => {
        if (isSelected) {
          column.deselect();
          table.removeFilter(column);
        } else {
          column.select();
          if (!table.containsColumn(column)) {
            table.filters.push(column);
          }
        }
        table.updateColumns();
      },
      isSelected ? "Deselect" : "Select",
      "table-sort"
    );
    menu.addAction(() => {
      table.reset();
    }, "Reset filters", "table-sort");
  };
}
function hasClickedTable(element) {
  const parent = element.closest(".table-editor");
  if (!parent)
    return false;
  return true;
}

// main.ts
var TableSort = class _TableSort extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.storage = [];
  }
  *autoIncrement() {
    let index = 0;
    while (true) {
      yield index++;
    }
  }
  getTableElement(th) {
    return th.closest(".table-editor") || void 0;
  }
  getTableID(table) {
    var _a;
    const id = (_a = table.getAttribute("id")) == null ? void 0 : _a.replace(idPrefix, "");
    return id ? parseInt(id) : this.gen.next().value;
  }
  hasCustomClasses(table) {
    const classes = table.getAttribute("class") || "";
    if (classes.length > 0) {
      return true;
    }
    return false;
  }
  isNewTable(id) {
    return this.storage.length - 1 >= id ? false : true;
  }
  async loadSettings() {
    _TableSort.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  static log(out, ...optionalParams) {
    if (this.settings.isDevmodeEnabled === false) {
      return;
    }
    console.log(out, optionalParams);
  }
  async saveSettings() {
    await this.saveData(_TableSort.settings);
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new TableSortSettingsTab(this.app, this));
    this.gen = this.autoIncrement();
    this.storage = [];
    const mousedownHandler = getMousedownHandler(this);
    this.registerDomEvent(document, "contextmenu", mousedownHandler, {
      capture: true
    });
    _TableSort.log("( obsidian-table-sorting ) Plugin has finished loading.");
  }
  onunload() {
    this.storage = [];
  }
};
